#!/usr/bin/env bash

# Exit if Gearlever isn't installed
if ! flatpak list | grep -q "it.mijorus.gearlever"; then
    echo "Gearlever not installed. Skipping AppImage updates."
    exit 0
fi

echo "=== Updating AppImages ==="

# Function to attempt updates
perform_update_check() {
    # Get list of installed AppImages
    APPS=$(flatpak run it.mijorus.gearlever --list-installed || true)

    if [ -z "$APPS" ]; then
        echo "No AppImages managed by Gearlever found."
        return 0
    fi

    # Initialize array to track locked/busy apps
    BUSY_APPS=()
    FAILED_APPS=()

    # Loop through apps using process substitution to keep array scope
    while read -r LINE; do
        # Extract clean path (last column)
        APP_PATH=$(echo "$LINE" | awk '{print $NF}')
        
        if [ -n "$APP_PATH" ] && [ "$APP_PATH" != "managed" ]; then
            APP_NAME=$(basename "$APP_PATH")
            echo "-> Checking updates for $APP_NAME..."
            
            # Create temp log to capture output
            LOG_FILE=$(mktemp)
            
            # Run update, capture both stdout and stderr
            if ! flatpak run it.mijorus.gearlever --update "$APP_PATH" -y > "$LOG_FILE" 2>&1; then
                # Update failed, check if it was due to being busy
                if grep -qi "Text file busy" "$LOG_FILE"; then
                    echo "   ⚠️  Update failed: App is running."
                    BUSY_APPS+=("$APP_NAME")
                else
                    # Some other error occurred
                    echo "   ⚠️ Update failed with error:"
                    cat "$LOG_FILE"
                    FAILED_APPS+=("$APP_NAME")
                fi
            else
                echo "   [OK] Update successful (or not needed)."
            fi
            
            rm -f "$LOG_FILE"
        fi
    done < <(echo "$APPS")

    # If we found busy apps, return failure status so we loop
    if [ ${#BUSY_APPS[@]} -gt 0 ]; then
        echo ""
        echo "The following apps could not be updated because they are running:"
        for app in "${BUSY_APPS[@]}"; do
            echo "   - $app"
        done
        return 1
    fi
    
    return 0
}

# --- Main Retry Loop ---
while true; do
    if perform_update_check; then
        echo "AppImage update check complete."
        exit 0
    else
        echo ""
        read -p "Close the apps listed above and press [Enter] to retry, or type 's' to skip: " CHOICE
        
        if [[ "$CHOICE" == "s" || "$CHOICE" == "S" ]]; then
            echo "Skipping remaining AppImage updates."
            exit 0
        fi
        
        echo "Retrying..."
        echo ""
        # Small sleep to allow file handles to release
        sleep 1
    fi
done